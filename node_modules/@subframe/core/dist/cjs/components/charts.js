"use client";
'use strict';

var _tslib = require('../_virtual/_tslib.js');
var index = require('../external/classnames/index.js');
var React = require('react');
var reactVirtualizedAutoSizer_esm = require('../packages/subframe-core/external/react-virtualized-auto-sizer/dist/react-virtualized-auto-sizer.esm.js');
var charts_module = require('./charts.module.css.js');
var XAxis$1 = require('../packages/subframe-core/external/recharts/es6/cartesian/XAxis.js');
var YAxis$1 = require('../packages/subframe-core/external/recharts/es6/cartesian/YAxis.js');
var Tooltip = require('../packages/subframe-core/external/recharts/es6/component/Tooltip.js');
var Legend = require('../packages/subframe-core/external/recharts/es6/component/Legend.js');
var Label = require('../packages/subframe-core/external/recharts/es6/component/Label.js');
var CartesianGrid$1 = require('../packages/subframe-core/external/recharts/es6/cartesian/CartesianGrid.js');

function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var React__namespace = /*#__PURE__*/_interopNamespaceDefault(React);

/**
 * Colors
 */
/* Default palette is Blue */
var DEFAULT_COLORS = ["3b82f6", "bfdbfe", "2563eb", "93c5fd", "1d4ed8", "60a5fa"];
function createColorMap(_a) {
    var categories = _a.categories, colors = _a.colors;
    var colorMap = new Map();
    for (var i = 0; i < categories.length; i++) {
        colorMap.set(categories[i], colors[i % colors.length]);
    }
    return colorMap;
}
var ChartContext = React__namespace.createContext(undefined);
function ChartContextProvider(_a) {
    var categories = _a.categories, colors = _a.colors, dark = _a.dark, children = _a.children;
    var value = React__namespace.useMemo(function () { return ({ colorMap: createColorMap({ categories: categories, colors: colors }), dark: dark }); }, [categories, colors, dark]);
    return React__namespace.createElement(ChartContext.Provider, { value: value }, children);
}
function useChartContext() {
    return React__namespace.useContext(ChartContext);
}
var AutoSizedChartWrapper = React__namespace.forwardRef(function AutoSizedChartWrapper(_a, ref) {
    var className = _a.className, style = _a.style, children = _a.children, props = _tslib.__rest(_a, ["className", "style", "children"]);
    return (React__namespace.createElement("div", _tslib.__assign({ className: index(className, charts_module.root), ref: ref }, props, { style: _tslib.__assign(_tslib.__assign({}, style), { minHeight: 200, minWidth: 300 }) }),
        React__namespace.createElement(reactVirtualizedAutoSizer_esm, null, function (_a) {
            var height = _a.height, width = _a.width;
            return children({ height: height, width: width });
        })));
});
/**
 * Recharts Wrappers
 */
var ChartLabel = Label.Label;
var CartesianGrid = function (_a) {
    var _b;
    var ref = _a.ref, className = _a.className, _c = _a.horizontal, horizontal = _c === void 0 ? true : _c, _d = _a.vertical, vertical = _d === void 0 ? false : _d, _e = _a.strokeWidth, strokeWidth = _e === void 0 ? 1 : _e, otherProps = _tslib.__rest(_a, ["ref", "className", "horizontal", "vertical", "strokeWidth"]);
    var dark = useChartContext().dark;
    return (React__namespace.createElement(CartesianGrid$1.CartesianGrid, _tslib.__assign({ className: index(className, charts_module.grid, (_b = {}, _b[charts_module.dark] = dark, _b)), horizontal: horizontal, vertical: vertical, strokeWidth: strokeWidth, ref: ref }, otherProps)));
};
CartesianGrid.displayName = CartesianGrid$1.CartesianGrid.displayName;
var XAxis = function (props) {
    return React__namespace.createElement(XAxis$1.XAxis, _tslib.__assign({}, props));
};
XAxis.displayName = XAxis$1.XAxis.displayName;
XAxis.defaultProps = _tslib.__assign(_tslib.__assign({}, XAxis$1.XAxis.defaultProps), { axisLine: false, tickLine: false, padding: { left: 20, right: 20 }, interval: "equidistantPreserveStart" });
var YAxis = function (props) {
    return React__namespace.createElement(YAxis$1.YAxis, _tslib.__assign({}, props));
};
YAxis.displayName = YAxis$1.YAxis.displayName;
YAxis.defaultProps = _tslib.__assign(_tslib.__assign({}, YAxis$1.YAxis.defaultProps), { axisLine: false, tickLine: false, width: 40 });
function DefaultTooltip(_a) {
    var _b;
    var active = _a.active, colorMap = _a.colorMap, dark = _a.dark, payload = _a.payload, label = _a.label;
    if (active && payload && payload.length) {
        return (React__namespace.createElement("div", { className: index(charts_module.tooltip, (_b = {}, _b[charts_module.dark] = dark, _b)) },
            label ? React__namespace.createElement("div", null, label) : null,
            payload.map(function (_a, index) {
                var name = _a.name, value = _a.value;
                return (React__namespace.createElement("div", { className: charts_module.row, key: index },
                    React__namespace.createElement("span", { className: charts_module.dot, style: { backgroundColor: colorMap.get(String(name)) } }),
                    React__namespace.createElement("span", { className: charts_module.name }, name !== null && name !== void 0 ? name : ""),
                    React__namespace.createElement("span", { className: charts_module.value }, value)));
            })));
    }
    return null;
}
var ChartTooltip = function (props) {
    var _a = useChartContext(), colorMap = _a.colorMap, dark = _a.dark;
    return (React__namespace.createElement(Tooltip.Tooltip, _tslib.__assign({ content: function (_a) {
            var active = _a.active, payload = _a.payload, label = _a.label;
            return (React__namespace.createElement(DefaultTooltip, { active: active, colorMap: colorMap, dark: dark, label: label, payload: payload }));
        } }, props)));
};
ChartTooltip.displayName = Tooltip.Tooltip.displayName;
ChartTooltip.defaultProps = _tslib.__assign(_tslib.__assign({}, Tooltip.Tooltip.defaultProps), { cursor: { stroke: "#D1D5DB", strokeWidth: 1 }, isAnimationActive: false });
function DefaultLegend(_a) {
    var _b;
    var align = _a.align, colorMap = _a.colorMap, dark = _a.dark, payload = _a.payload;
    return (React__namespace.createElement("div", { className: index(charts_module.legend, (_b = {},
            _b[charts_module.dark] = dark,
            _b[charts_module.left] = align === "left",
            _b[charts_module.center] = align === "center",
            _b[charts_module.right] = align === "right",
            _b)) }, payload.map(function (_a, index) {
        var value = _a.value;
        return (React__namespace.createElement("div", { className: charts_module.row, key: index },
            React__namespace.createElement("span", { className: charts_module.dot, style: { backgroundColor: colorMap.get(String(value)) } }),
            React__namespace.createElement("span", { className: charts_module.name }, value)));
    })));
}
var ChartLegend = function (_a) {
    var ref = _a.ref, otherProps = _tslib.__rest(_a, ["ref"]);
    var _b = useChartContext(), colorMap = _b.colorMap, dark = _b.dark;
    return (React__namespace.createElement(Legend.Legend, _tslib.__assign({ content: function (_a) {
            var payload = _a.payload;
            return (React__namespace.createElement(DefaultLegend, { align: otherProps.align, colorMap: colorMap, dark: dark, payload: payload }));
        }, ref: ref }, otherProps)));
};
ChartLegend.displayName = Legend.Legend.displayName;
ChartLegend.defaultProps = _tslib.__assign(_tslib.__assign({}, Legend.Legend.defaultProps), { align: "right", verticalAlign: "top" });

exports.AutoSizedChartWrapper = AutoSizedChartWrapper;
exports.CartesianGrid = CartesianGrid;
exports.ChartContextProvider = ChartContextProvider;
exports.ChartLabel = ChartLabel;
exports.ChartLegend = ChartLegend;
exports.ChartTooltip = ChartTooltip;
exports.DEFAULT_COLORS = DEFAULT_COLORS;
exports.XAxis = XAxis;
exports.YAxis = YAxis;
exports.createColorMap = createColorMap;
exports.useChartContext = useChartContext;
